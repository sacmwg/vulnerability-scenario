# SACM Vulnerability Assessment Hackathon Information
This page documents the intent of our SACM hackathon planned for IETF 99, and also functions as the starting point for documenting outcomes from work being tracked in <https://github.com/sacmwg/vulnerability-scenario/projects/1>. 


## Goals and Outcomes

Originally determined on-list (see ​<https://mailarchive.ietf.org/arch/msg/sacm/LskQ7tj9Wvy1-0DSlEN_VakYj64>)

**GOAL:** Running code demonstrating the communication needs between identified components as they pertain to the on-request collection case through the scenario, where that case is described at <https://trac.ietf.org/trac/sacm/wiki/SacmVulnerabilityAssessmentScenario>.

**OUTCOME:** We will have specific understanding of components' boundaries and the necessary information flows (including information being communicated) between them.

**GOAL:** Leverage existing collected data in a data repository.

**OUTCOME:** Demonstrate that previously collected data can be reused to support vulnerability assessment

**GOAL:** Running code to extend that base case to include a mechanism capable of monitoring a given set of endpoint attributes for change.

**OUTCOME:** We will have specific understanding of additional architectural considerations for handling monitoring vs. on-request collection, as well as any additional information flows required.

**GOAL:** Wherever possible use existing standards and explicitly identify where such standards are unavailable or do not exist

**OUTCOME:** We will have a deployment and operational document demonstrating where standards were leveraged and where they did not exist, which identifies potential areas of future work.

## User Story

A vendor identifies a vulnerability in their software product being exploited in the wild. The vendor produces a new version of their software and publishes a vulnerability bulletin (Vulnerability Description Information) that advises customers to upgrade to this new version to address the vulnerability. The product versions have both a SWID tag and a CoSWID tag. As a customer using the affected products, we need to build a vulnerability assessment system that is capable of detecting which version of the software is installed and compare that version with the affected versions, so that we know whether we are presently vulnerable. The Collector (or Collectors) will be capable of gathering software inventory information from one or more target endpoints by:

1. Requesting software inventory information for the affected software based on an ad-hoc request.
2. Reporting the software inventory as software changes occur

Collected software inventory information will be stored in an Endpoint Repository and will be compared to Vulnerability Detection Data retrieved from the Vulnerability Detection Data Repository - results will be stored in the Assessment Results Repository. The Vulnerability Detection Data will be derived from the vendor-provided information in some useful way to be determined by the Vulnerability Assessor. (This derivation need not be automatic for the purpose of this exercise.)

## Components and Existing Functionality

Agreed upon components are (as discussed here: ​<https://mailarchive.ietf.org/arch/msg/sacm/u2cppct5RgwnOdfQoZnlkMN7t2w>):

* Vulnerability Detection Data Repository (VDD Repository)
* Vulnerability Assessor
* Endpoint Repository
* Collector
* Target Endpoint
* Assessment Results Repository

Several sources have come forward to offer existing functionality we might leverage for this effort. The following table provides these details. NOTE: This table is not yet final; expect changes.

| Component | Code Module/Function | Responsible Provider | Code/Component URL | Is SACM Component? |
|-----------|----------------------|----------------------|--------------------|--------------------|
| VDD Repository | ROLIE Implementation | Stephen Banghart |  | Yes |
| Vulnerability Assessor | CIS-CAT Pro Assessor<br>StrongSwan (??)| Bill Munyan<br>Andreas Steffan |  | Yes |
| Endpoint Repository | StrongSwan | Andreas Steffan | [SWIMA PA-TNC](https://github.com/strongswan/strongswan/tree/swima) | Yes |
| Collector | StrongSwan<br>CIS-CAT Pro Asseessor | Andreas Steffan<br>Bill Munyan | [SWIMA PA-TNC](https://github.com/strongswan/strongswan/tree/swima) | Yes |
| Target Endpoint | Local resources<br>AWS VPC | Local - multiple<br>Adam Montville | | Yes |
| Assessment Results Repository | CIS-CAT Pro Dashboard<br>StrongSwan (??) | Bill Munyan<br>Andreas Steffan | | Yes |
| OVAL Builder for Windows | XORCISM | Jerome Athias (remote participant) | [OVAL Builder]() | No |
| SWID Generator | TBD | Dave Waltermire | | No|


Here's roughly what we're thinking at this point when it comes to the _basic_ sequence. NOTE: There are other desires (see the goals and outcomes above) that are not necessarily represented by this diagram.

![Sequence Diagram](https://raw.githubusercontent.com/sacmwg/vulnerability-scenario/master/ietf_99_hackathon/graphics/vulnerability_scenario_sequence_diagram.png)

Given that diagram, we see the general communication patterns we expect to be in place. What is also not represented are some of the supporting efforts we might need. For example, we may need a SWID/CoSWID generator, which is not considered a SACM component, but may be necessary for the success of the hackathon. To go along with this sequence diagram, we've started building a deployment diagram.

![Deployment Diagram](https://raw.githubusercontent.com/sacmwg/vulnerability-scenario/master/ietf_99_hackathon/graphics/hackathon_deployment.png)

This diagram begins to answer some of our communication and logistical questions, but seems to raise just as many. What certificates, pre-shared keys, and other logistical concerns might we have? Where will each of these actually run (i.e. local VM, local hardware, cloud environment)? Who is responsible for bringing each component, and what do we do if someone is unable to make it?

Finally, the diagrams above support our User Story, but also assume some preconditions. The most important of these preconditions is that the Endpoint Repository has been "loaded" with endpoint data. Another way to put this is that some Collector has already gathered at least some desired endpoint attributes from one or more target endpoints and put them into the Endpoint Repository. Another precondition is that each of these components are pre-configured to talk to one another. This means that, as part of the hackathon, we need to ensure that any pre-shared keys, certificates, IP addresses, and the like are worked out _ahead of time_ where ever possible. What is the full set of preconditions?

The following is a list of candidate vulnerabilities we might attempt to detect, although these may present some risk on the local network, should we decide these are what we are wanting to do. We might instead simulate vulnerable/patched software.

* Apache Struts: [CVE-2017-5638](https://nvd.nist.gov/vuln/detail/CVE-2017-5638)
* Linux kernel: [https://dirtycow.ninja/](https://dirtycow.ninja/) (also [CVE-2016-5195](https://nvd.nist.gov/vuln/detail/CVE-2016-5195))
* Xen: [CVE-2017-10912](https://nvd.nist.gov/vuln/detail/CVE-2017-10912)
* Ncurses: [CVE-2017-10685](https://nvd.nist.gov/vuln/detail/CVE-2017-10685)
* Perl XML-LibXML: [CVE-2017-10672](https://nvd.nist.gov/vuln/detail/CVE-2017-10672)

## Outcomes
Our hackathon took place in Prague just before and during the start of IETF 99. Over the course of that weekend, we were able to complete the desired flow listed above. We had some key learnings, not the least of which is that we should attempt to focus our efforts heavily on wide-net collection and upon defining a robust evaluation/query language. We also wished we had the ability to filter for SWIDs of a particular shape.


### A Related Hackathon Effort
While we were working on our efforts described above, others in a cross section of SACM, MILE, and I2NSF were working on a YANG-push-based method of collection with downstream dissemination of collected information to an XMPP Grid. Roughly, their appraoch looked like the following.

![XMPP Diagram](https://raw.githubusercontent.com/sacmwg/vulnerability-scenario/master/ietf_99_hackathon/graphics/hackathon_deployment_alternative.png)

### Integrating These Approaches
The following depicts a possible way forward for integrating these two efforts. The depiction below shows collection of software identification information from one endpoint using SWIMA (which is software identification over PT-TLS - it's not difficult to imagine other collection types going over PT-TLS). In this case, the SACM Collector are the StrongSWAN and PT-TLS Client working together. Similarly, collection from network equipment (target endpoints A and B in this diagram) may get to some SACM collector using YANG-push. Both SACM collectors could then publish that collected information to some XMPP-Grid Controller, in this case a broker. The endpoint repository of our hackathon effort (StrongTNC) would then receive the information, and our assessor (CIS-CAT Pro in our hackathon effort) would be able to query that information at will, each using the XMPP-Grid approach of disseminating downstream collection information.

![Combined Diagram](https://raw.githubusercontent.com/sacmwg/vulnerability-scenario/master/ietf_99_hackathon/graphics/hackathon_deployment_combined.png)